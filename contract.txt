// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StudentRegistry {
    struct Student {
        string name;
        bool exists;
        address walletAddress;
    }

    mapping(uint256 => Student) public students;
    address public admin;

    uint256[] public verifiedStudentIDs;

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }

    constructor() {
        admin = msg.sender;
    }

    function addStudents(uint256[] memory _ids, string[] memory _names) public onlyAdmin {
        require(_ids.length == _names.length, "IDs and names length mismatch");

        for (uint256 i = 0; i < _ids.length; i++) {
            students[_ids[i]] = Student(_names[i], true, address(0)); // Initialize walletAddress as address(0)
        }
    }

    function verifyStudent(uint256 _id) public {
        require(students[_id].exists, "Student does not exist");
        require(students[_id].walletAddress == address(0), "Student already verified");

        students[_id].walletAddress = msg.sender;
        verifiedStudentIDs.push(_id);
    }

    function getStudentWalletAddress(uint256 _id) public view returns (address) {
        return students[_id].walletAddress;
    }

    function isStudentVerified(uint256 _id) public view returns (bool) {
        return students[_id].walletAddress != address(0);
    }

 function getVerifiedStudents() public view returns (uint256[] memory, address[] memory) {
    uint256[] memory ids = new uint256[](verifiedStudentIDs.length);
    address[] memory addresses = new address[](verifiedStudentIDs.length);

    for (uint i = 0; i < verifiedStudentIDs.length; i++) {
        ids[i] = verifiedStudentIDs[i];
        addresses[i] = students[verifiedStudentIDs[i]].walletAddress;
    }

    return (ids, addresses);
}

}
